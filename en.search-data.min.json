[{"id":0,"href":"/Wiki/Algorithm/test/","title":"[프로그래머스 연습문제 풀이] 2019 카카오 개발자 겨울 인턴십 - 크레인 인형뽑기 게임","parent":"Algorithm","content":"코딩테스트 연습 - 크레인 인형뽑기 게임\n문제의 의도\n 문제 파악 능력 기본적인 배열의 사용 논리적으로 배열 사용할 수 있는지 확인 기본적인 문제로서 문제를 정확히 파악하고 배열을 논리적으로 사고할 수 없으면 시간이 소요되어 다른 문제를 풀 수 없음  프로그래머스에서 푸는 알고리즘 연습문제의 첫단추인만큼 기본 틀부터 만들었다. Github에 올려야겠다.\n  틀 보기\n\u0026#34;\u0026#34;\u0026#34; 분류 : 코딩테스트 연습 / 2019 카카오 개발자 겨울 인턴십 문제명 : 크레인 인형뽑기 게임 URL : https://programmers.co.kr/learn/courses/30/lessons/64061 \u0026#34;\u0026#34;\u0026#34; import pprint # 디버깅용 def solution(board, moves): answer = 0 return answer pp = pprint.PrettyPrinter(indent=4) TEST_CASES = [ { \u0026#34;board\u0026#34;: [[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]], \u0026#34;moves\u0026#34;: [1, 5, 3, 5, 1, 2, 1, 4], \u0026#34;result\u0026#34;: 4 } ] def TEST(): for i, test_case in enumerate(TEST_CASES): test_case_str = \u0026#34;#%d\\n%s\u0026#34; % (i, pprint.pformat(test_case)) print(test_case_str) answer = solution(test_case[\u0026#34;board\u0026#34;], test_case[\u0026#34;moves\u0026#34;]) if answer is test_case[\u0026#34;result\u0026#34;]: print(\u0026#34;ok\u0026#34;) else: print(\u0026#34;not ok(%s/%s)\u0026#34; % (answer, test_case[\u0026#34;result\u0026#34;])) print(\u0026#34;\\n\\n\u0026#34;) TEST()   문제 파악을 잘하자. 주어진 테스트 케이스도 꼼꼼히 확인하자.    일단 이 문제를 풀 때 시간이 오래 걸린 지점은 문제파악이었다. 배열을 그려놓고 예제를 잘 읽어보지 않아서 아래와 같이 착각했다. 테스트케이스의 결과는 맞았지만 채점해보니 전부 틀렸다. 예제를 잘 보니 그냥 배열 그림 보이는대로 판이 만들어지는 거였다.\n왜 이렇게 생각했을까..\n이렇게 보는게 맞다.\n이 문제의 핵심은 배열의 rotate라고 생각했다.\nboard = [[0, 0, 0, 0, 0], [0, 0, 1, 0, 3], [0, 2, 5, 0, 1], [4, 2, 4, 4, 2], [3, 5, 1, 3, 1]], move의 1이라함은 board의 row를 뜻하므로 위 배열에서는 board[0][1]을 빼야한다.\n그런데 board를 rotate하면 훨씬 쉬워진다.\n[ [3, 4, 0, 0, 0], [5, 2, 2, 0, 0], [1, 4, 5, 1, 0], [3, 4, 0, 0, 0], [1, 2, 1, 3, 0]] 이렇게 만들어 놓으면 board의 move에 해당하는 열의 가장 마지막 index를 뺴주기만하면 된다.\n  정답\ndef rotated(board): list_of_tuples = zip(*board[::-1]) return [list(elem) for elem in list_of_tuples] def reduce_space(board): for i, line in enumerate(board): board[i] = list(filter(lambda x: x != 0, line)) def solution(board, moves): answer = 0 bascket = [] board = rotated(board) reduce_space(board) for move in moves: if len(board[move-1]) \u0026gt; 0: item = board[move-1].pop() if item == 0: continue if len(bascket) \u0026gt; 0 and bascket[-1] == item: bascket.pop() answer = answer+2 else: bascket.append(item) return answer   다른 유저들의 정답\n정사각형이란 조건이 있으므로 이를 이용해도 된다. (1)부분\ndef solution(board, moves): stacklist = [] answer = 0 for i in moves: for j in range(len(board)): if board[j][i-1] != 0: stacklist.append(board[j][i-1]) #----(1) board[j][i-1] = 0 if len(stacklist) \u0026gt; 1: if stacklist[-1] == stacklist[-2]: stacklist.pop(-1) stacklist.pop(-1) answer += 2 break return answer   가독성도 좋지만 이런 간단한 문제는 저런식으로 배열 원소 접근만 잘하면 간결하게 끝낼 수 있을 것 같다.\n"},{"id":1,"href":"/Wiki/Algorithm/","title":"Algorithm","parent":"Wiki","content":"Hello\n"},{"id":2,"href":"/","title":"Introduce","parent":"","content":"Hello\n"},{"id":3,"href":"/Wiki/","title":"Wiki","parent":"Introduce","content":"Hello\n"},{"id":4,"href":"/%EC%83%9D%EA%B0%81/","title":"생각","parent":"Introduce","content":"Hello\n"},{"id":5,"href":"/categories/","title":"Categories","parent":"Introduce","content":""},{"id":6,"href":"/tags/","title":"Tags","parent":"Introduce","content":""}]