[{"id":0,"href":"/Database/","title":"Database","parent":"@hwangseonbi","content":""},{"id":1,"href":"/DevOps/","title":"DevOps","parent":"@hwangseonbi","content":""},{"id":2,"href":"/Frontend/","title":"Frontend","parent":"@hwangseonbi","content":""},{"id":3,"href":"/DevOps/1688b1f5-d4f2-4c98-9940-ab8592717211/","title":"Kubernetes configuration pattern에 대하여","parent":"DevOps","content":" 이 블로그는 Notion에서 랜더링 자동화를 통해 제작되었습니다.\nNotion 페이지에 최적화되어있습니다. → Kubernetes configuration pattern에 대하여\n   1. EnvVar Configuration 2. Configuration Resouece 3. Immutable Configuration    1) Docker 2) Kubernetes     4. Configuration Template    Kubernetes Pattern\nPart IV. Configuration Patterns 참고\n 1. EnvVar Configuration    가장 간단한 방법이다. Config Data의 개수가 적고 단순할 때 사용하기 적합하다.\n  default ENV는 이미지에 정의해준다.\n1 2 3 4 5 6  FROMubuntu:latestENV BACKEND_URL \u0026#34;/backend\u0026#34;ENV PROFILE = \u0026#34;DEV\u0026#34;...\t     어플리케이션에서 접근한다. 환경변수로 PROFILE만 주입해주고 어플리케이션 내부에서 PROFILE에 따라 다른 config를 불러오는 것도 하나의 방법이다. (많이 쓰임)\n1 2 3 4 5  contentsTableRefresh:function(){ const url = `${process.env.BACKEND_URL}/videos/contents` fetch(url) ...      Kubernetes 정의 파일에서 env를 주입한다. 문자열로 직접 삽입할 수도 있으며 configMap이나 Secret을 참조하여 받아올 수도 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  apiVersion:v1kind:Podmetadata:name:random-generatorspec:containers:- image:my/jsproject:1.0name:jsprojectenv:- name:BACKEND_URLvalue:http://localhost:8080- name :PROFILEvalueFrom:...      장점\n  간편하다.\n  어떤 어플리케이션이든, 어떤 베이스 이미지든 통용되므로 범용성이 좋다.\n  단점\n  안전하지 않다.\n  복잡한 Config를 다루기에는 맞지 않다. (그 많은걸 어떻게 다 핸들링할것인가!)\n  ENV를 주입할 수 있는 계층이 나눠져 있어서 디버깅하기 어렵다. (Image에서 정의될 수도, K8S정의에서 정의될 수도, APP에서 정의될 수도 있으니..)\n  Immutable 하다. 즉 APP이 시작되기 전에 세팅되서 나중에 변경하기 힘들다. → Rolling update할 때 config 바뀔일이 없으니 장점일 수도? 암튼!\n  2. Configuration Resouece    위 EnvVar Configuration 패턴에서 조금 변형된 패턴이다.\n이 패턴을 사용하면 좋은 점\n  config로 사용할 데이터들을 하나의 지점에서 관리할 수 있다.\n  configMap을 Pod에서 파일로 마운트 시키면 configMap 변경 사항이 반영되게 할 수도 있다.\n  EnvVar Conf 패턴에서는 Pod 정의에 env를 직접 문자열로 때려넣었다면 이 패턴에서는 K8S 네이티브 리소스인 ConfigMap과 Secret를 사용하여 넣는 것이다. ConfigMap과 Secret은 기술적으로는 동일하고 사용법도 동일하다.\n물론 제한 사항도 있으니 체크필요! (ex. Secret은 1MB 제한)\n1 2 3 4 5 6 7 8 9 10 11 12  apiVersion:v1kind:ConfigMapmetadata:name:my-configdata:BACKEND_URL:/backendapplication.properties:|# App properties configlog.file=/tmp/myapp.logserver.port=7070EXTRA_OPTIONS:\u0026#34;high-secure,native\u0026#34;...   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  apiVersion:v1kind:Podmetadata:name:random-generatorspec:containers:- image:my/application:1.0name:myapplicationvolumeMounts:- name:config-volumemountPath:/config- env:- name:BACKEND_URLvalueFrom:configMapKeyRef:name:my-configkey:BACKEND_URLprefix:CONFIG_volumes:- name:config-volumeconfigMap:name:my-config   💡참고 : **Secret은 그다지 secret하지 않다. 그러므로 민감한 정보라면 어플리케이션 단에서도 암호화할 필요가 있다. -** Secure은 Base64로 인코딩되어 저장되어있다. 그리고 파드에 넣어지기 직전에 디코딩된다. - Secret의 아래와 같은 특징이 있긴하다. - Secret은 Pod가 실행되고있는 노드에만 배포된다. - 해당 노드에서 secret은 메모리에 저장된다. pod가 제거되면 같이 제거된다. - ETCD에서 secret은 암호화된 형태로 저장된다. - 그래도 어쨌든 root user가 아닌 user도 접근해서 볼 수 있다. (role-based access control 적용하더라도, pod 생성 권한만 있으면 마운트시켜서 볼 수 있음) \n3. Immutable Configuration    이 패턴을 사용하면 좋은점\n  Immutability 컨트롤 가능\n envVar config 패턴에서는 immutability가 패시브로 강제였지만 여기서의 immutability는 원하는 시점에 immutable하게 할 수 있다는 뜻. 예를들면 어플리케이션이 시작되고나면 바꿀수 없게 한다던지.    config의 버전관리 가능\n  ConfigMap이나 Secret의 용량제한을 뛰어넘을 수 있음\n  How?\nconfig 관리 컨테이너 이미지를 만들어놓고 어플리케이션 런타임 때 이 컨테이너를 참조한다. 참조하는 방법은 플랫폼에 따라서 다양한 방법으로 가능.\n1) Docker    volume-from 옵션으로 다른 컨테이너의 volume 참조\n1 2 3 4 5  docker create --name config-dev myapplication-config-dev:1.0.1 docker run --volume-from config-dev myapplication:1.0 docker create --name config-prdt myapplication-config-prdt:1.0.1 docker run --volume-from config-prdt myapplication:1.0        2) Kubernetes    Kubernetes에서는 Docker의 volume-from 같은 명령을 지원하지 않는다. 다른 방법이 있는데 Init Container을 사용하면 된다.\n1 2 3  FROMbusyboxADD dev.properties /config-src/demo.propertiesENTRYPOINT [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cp /config-src/* $1\u0026#34;, \u0026#34;--\u0026#34;]   Deployment의 Pod 템플릿에서는 하나의 volume과 두개의 컨테이너를 가지게된다.\n     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  ...initContainers:- image:k8s/patterns/config-dev:1name:initargs:- \u0026#34;/config\u0026#34;volumeMounts:- mountPath:\u0026#34;/config\u0026#34;name:config-directorycontainers:- image:k8spatterns/demo:1name:demoports:- containerPort:8080name:httpprotocol:TCPvolumeMounts:- mountPath:\u0026#34;/config\u0026#34;name:config-directoryvolumes:- name:config-directoryemptyDir:{}    \u0026ldquo;config-directory\u0026quot;라는 이름의 volume을 통해서 initContainers를 거쳐 실제 app 컨테이너로 config가 카피된다.  만약 config를 현재 dev에서 prdt로 바꾸고 싶다면, init container의 image만 바꾸면 된다. (yaml을 통해서든 kubectl을 통해서든) 근데 이방법도 안전하지 않은데?? 그리고 hot reload도 안될듯..\nOpenShift Template에서는 이 부분은 쉽게 파라미터를 넘기는 식으로 사용가능하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  apiVersion:v1kind:Templatemetadata:name:demoparameters:- name:CONFIG_IMAGEdescription:Name of configuration imagevalue:k8spatterns/config-dev:1objects:- apiVersion:v1kind:DeploymentConfig// ...spec:template:metadata://...spec:initContainers:- name:initimage:${CONFIG_IMAGE}args:[\u0026#34;/config\u0026#34;]volumeMounts:- mountPath:/configname:config-directorycontainers:- image:k8spatterns/demo:1//...volumeMounts:- mountPath:/configname:config-directoryvolumes:- name:config-directoryemptyDir:{}   1  oc new-app demp -p CONFIG_IMAGE=k8spatterns/config-prod:1   책에서 말하는 장점과 단점은 아래와 같다.\n장점\n  container 내부에 config가 들어있으므로 버전관리가 가능하다.\n  Configuration created this way can be distributed over a container registry. The configuration can be examined even without accessing the cluster. → \u0026ldquo;config는 컨테이너 레지스트리를 넘어서 배포가 되므로 클러스터에 직접 접근하지 않아도 확인가능하 다.\u0026rdquo; 라는 말인데, 흠\u0026hellip; 두가지 때문에 이말을 한것같은데 확실하게 모르겠다.\n   클러스터 내부로 들어가지 않아도 컨테이너 레지스트리에 접근 가능해서 하는 말이거나(몰랐음ㅋ) 컨테이너 레지스트리 파일시스템에서 확인 가능하므로 하는 말이거나    config가 컨테이너 이미지 안에 들어있으므로 Immutable하다.\n  복잡한 config도 다루기 쉬움. 사이즈가 큰 파일도 가능.\n  단점\n  라이프사이클이 복잡함, 이미지 빌드 관리 포인트가 늘어남.\n  민감한 데이터에 대한 concern이 없음.\n  환경 별로 다른 deployment가 필요. (또는 수정 필요)\n  👉그런데 내 생각에는, 이 방법은 복잡성이 높아서 왠만하면 피해야겠다.. 물론 버전관리가 된다는 점에서는 좋은 점 같긴하나 어플리케이션 개발에 따라 config도 변하기마련인데, 별도로 버전관리를 해야한다는게 오히려 짐이 늘어나는 것 같아 그리 장점으로 느껴지지가 않는다. 게다가 이 글을 쓰게된 처음 원칙을 떠올려보면, \u0026quot;config 변경으로 인해 Application의 빌드를 다시하면 안된다\u0026quot; 였는데 물론 Application 이미지는 그대로이긴하다. 그러나 이렇게 하는 이유로는 Application의 환경별 일관성도 있지만 개발자로서 개발하기 편하게 하기위함도있다. 그런데 이방법으로는 개발자는 괴로워질 것 같다.. CI/CD 면에서 관리 포인트도 늘어나고 config 수정이 매우 어려울 듯(hot reload도 불가능). \n4. Configuration Template    이 패턴은 3. Immutable Configuration에서 조금 진화된 것이라고 보면된다. 매우 복잡한 config이고 환경별로 거의 비슷한 config data를 가진다면 중복되는 부분이 많을 것이다. 따라서 일부 다른 부분만 바꿔주고 나머지 동일한 부분은 중복되어 리소스낭비를 줄일 수 있다.\n이 일을 하는 Configuration Template Tool들을 init container에서 사용하면 된다. Tiller (Ruby) or Gomplate (Go) 같은 것들이 있다.\n     이 패턴은 복잡성 때문에 config data가 매우 큰 경우에만 사용하는게 좋을 것이다.\n"},{"id":4,"href":"/Posts/","title":"Posts","parent":"@hwangseonbi","content":""},{"id":5,"href":"/%EC%83%9D%EA%B0%81/","title":"생각","parent":"@hwangseonbi","content":""},{"id":6,"href":"/Frontend/79ac381b-6bb1-4b0b-96a2-d440d0302a78/","title":"CSS Box 모델에 대하여","parent":"Frontend","content":" 이 블로그는 Notion에서 랜더링 자동화를 통해 제작되었습니다.\nNotion 페이지에 최적화되어있습니다. → CSS Box 모델에 대하여\n  1. \u0026lt;div\u0026gt;로 박스먼저 만들기 2. boder 속성 살펴보기 3. 사각형 내부에 다른 요소가 들어있다면? 4. 그러면 외부 요소와 간격을 벌리고 싶을 땐? 5. 직접 계산해보기   크롬의 개발자도구 탭에서 요소를 검사할 때마다 나타나는 저 박스들\n     항상 궁금했었다. 도대체 무엇을 의미하는가\u0026hellip; 🥵\n 1. \u0026lt;div\u0026gt;로 박스먼저 만들기    padding이 뭔지 margin이 뭔지 정의 부터 보기전에 \u0026lt;div\u0026gt;태그로 사각형을 먼저 만들어보자.\nheight, width 속성으로 사이즈를 조절할 수 있다. 그리고 이에따라 주변의 요소들은 밀려나게된다.\n말끔한 날것의(?) blue 사각형이 만들어진다.\n     2. boder 속성 살펴보기    두번째로 볼 속성은 border이다. border 속성의 기본값은 none이라서 별도의 속성값을 주지 않으면 위에서 보았던 것처럼 경계선은 보이지 않게된다.\nsolid값을 줘보자. 그러면 사각형 테두리에 3px(기본값)짜리 경계선이 둘러쌓인다.\n중요한 것은 전체적인 div의 크기는 커졌지만 알맹이 사각형의 크기는 그대로인 상태에서 border의 픽셀수만 추가되었다는 것이다.\n     border-width 속성값을 많이주면 더 극명하게 차이가 보인다. 물론 0px로 설정하면 border는 사라지게 된다.\n     3. 사각형 내부에 다른 요소가 들어있다면?    이제 div 사각형 내부에 다른 요소가 들어있다고 해보자.\n     이때 글자들이 너무 왼쪽에 붙어있어 조금 여유를 두고싶을 때가 있다. 이럴 때 사용하는 것이 padding이다.\n     4. 그러면 외부 요소와 간격을 벌리고 싶을 땐?    반대로 외부요소와 외부요소 사이의 간격을 벌리고 싶을때 사용하는 것이 margin이다.\n     다음 예시를 보자. \u0026lt;div\u0026gt;태그 안에 \u0026lt;h1\u0026gt;태그와 \u0026lt;p\u0026gt;태그가 포함되어있는 단순한 html이다.\n     개발자 도구에서 보면 \u0026lt;p\u0026gt;태그에 margin이 들어간 것을 볼 수 있다. 이 값 때문에 \u0026lt;p\u0026gt;태그 위에있는 \u0026lt;h1\u0026gt;태그와 공간이 벌어져있는 것을 볼 수 있다. 주황색으로 표시된 부분\n5. 직접 계산해보기    컨텐츠의 영역을 직접 계산하여 아래와 같이 꼭지점을 잇는 사각형을 만들어보면 박스모델을 제대로 이해할 수 있다.\n     1 2 3 4 5 6  \u0026lt;div class=\u0026#34;container1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container3\u0026#34;\u0026gt; \u0026lt;/div\u0026gt;   아래 CSS 코드의 주석 처리된 부분을 풀면 위 결과물이 만들어진다. 왜 저만큼의 픽셀이 밀어져야하는지 생각해보시길.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  * { margin:0px; } .container1 { width:100px; height:100px; border:solid; border-width:5px; background-color:blue; /* margin-left:10px; */ } .container2 { width:100px; height:100px; background-color:red; border:solid; border-width:10px; /* margin-left:120px; */ } .container3 { width:100px; height:100px; background-color:yellow; border:solid; border-width:10px; /* margin-left:240px; */ }   ▼ 전역 속성 설정 이유 ↕  과제를 하다보면 이렇게 margin값을 주지 않았음에도 사각형 주위에 빈공간이 생긴다.\n     그 이유는 기본값 때문이다. 우리가 아무 속성값을 지정하지 않아도 기본적으로 \u0026lt;body\u0026gt;태그에 설정된 속성들이 있다. 그 중에서 margin이 8px으로 기본적으로 적용되어 있다.\n그래서 이렇게 \u0026lt;body\u0026gt;를 비롯한 모든 기본 margin값을 0px로 설정해놓은 것이다.\n  "},{"id":7,"href":"/Algorithm/","title":"Algorithm","parent":"@hwangseonbi","content":""},{"id":8,"href":"/Algorithm/6deb1329-a0df-4511-b16e-ead4ac2248a5/","title":"다익스트라 최단거리 알고리즘에 대하여","parent":"Algorithm","content":" 이 블로그는 Notion에서 랜더링 자동화를 통해 제작되었습니다.\nNotion 페이지에 최적화되어있습니다. → 다익스트라 최단거리 알고리즘에 대하여\n  1. 다익스트라 알고리즘 2. 아이디어 3. 알고리즘 4. 일반화 5. 구현 6. 전체 통합 소스 및 실행 결과    1. 다익스트라 알고리즘    다익스트라 알고리즘이 이해와 납득이 가지않아 며칠동안 앓았다. 블로그 몇개를 훑어보아서는 이해하기가 힘들었다\n(저 같이 집중안하고 대충 공부해보려다가는 시간만 날립니다. 한번 볼때 집중해서 흐름 따라가세요)\n나같은 사람을 위해 수학적으로 이 명제가 참이라는 것을 증명하기보다는 경험적으로 이해한 알고리즘의 흐름을 알아본다.\n2. 아이디어    ✅__다익스트라 알고리즘의 핵심__ : 특정 지점에서 다른 지점까지의 최단 거리는 인접 지점까지의 최단 거리로 이루어진다. \n몇개의 그래프를 가지고 최단경로를 구하는 생각을해보면 경험적으로 사실이란 것을 알 수 있다.\n아래 그래프상에서 A에서 B까지의 최단거리를 생각해보자.\n     내 머리속에서는 아래와 같은 사고의 흐름이 펼쳐진다.\n  직접 연결된 곳 먼저 가보자 Ⓐ→Ⓑ : 100 얼라? 거리가 좀 커보이네?\n  다른 곳 거쳐서 가보자 Ⓐ→Ⓒ→Ⓑ : 400+2 = 402 중간에 400 때문에 더 걸리네..\n  더 둘러가볼까 Ⓐ→Ⓒ→Ⓔ→Ⓑ = 2+4+1=7 거리값이 적은 곳으로 돌아오니 빠르군\n  여기서 주목해야할 포인트는 3번과정이다.\n3번 과정을 통해서 우리는 Ⓒ보다 먼 지점(Ⓓ 또는 Ⓔ)를 갈때는 Ⓐ→Ⓑ가 아닌 Ⓐ→Ⓒ를 거쳐야 최소값이 될 것 같다는 생각이 든다. 실제로도 그렇다. 다익스트라 형님의 아이디어가 바로 이 지점인 것이다.\n✅__다익스트라 알고리즘의 핵심__ : 특정 지점에서 목표 지점까지의 최단 거리는 목표 지점과 인접한 지점까지의 최단 거리로 이루어진다. \nⒺ지점을 최단거리로 가려면 Ⓔ와 인접한 노드인 Ⓑ, Ⓒ, Ⓓ 중 한곳을 거쳐와야할 것이다.\n그렇다면 A→E 최단거리는 Ⓐ→Ⓑ의 최단거리 또는 Ⓐ→Ⓒ의 최단거리 또는 Ⓐ→Ⓓ의 최단거리를 통해서 얻을 수 있는 것이다.\n3. 알고리즘    위 사고를 조금 더 체계화시킨 알고리즘 형태로 보자.\n A를 시작노드로 설정한다. 따라서 현재노드는 A이다. A와 인접한 노드의 간선을 계산한다.       다음 방문할 노드를 선택한다. 선택하는 기준은 아직 방문하지 않은 노드 중에서 가장 가까운 노드이다. A와 인접한 노드 중에서 가까운 곳은 C이다. C가 현재노드가 된다.  C노드와 인접한 노드들까지의 거리가 고려된 최단거리를 고려한다.       다시 C에서 아직 방문하지 않은 노드 중에서 가장 가까운 노드를 선택한다. 이번엔 D가 될 것이다.  이런 식으로 3번과정을 반복한다.\n4. 일반화    다시 일반화 시켜보면 아래와 같이 정리 가능하다.\n  출발 노드 설정\n  출발 노드를 기준으로 각 노드의 최소 비용을 저장\n  방문하지 않은 노드 중에서 가장 비용이 적은 노드 선택\n  해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용 갱신\n  위 과정에서 3번 ~ 4번을 반복\n  ⚠️[미리알림] 코드 구현 시, 3번 과정에서 비용이 가장 적은 노드를 선택할 때 그냥 배열을 돌면서 찾을 수도 있다. 하지만 우선순위 큐로 구현한다면 더 빠르게 선택할 수 있다. \n5. 구현    그래프가 아래와 같이 주어졌을 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  graph1 = { \u0026#39;A\u0026#39;: {\u0026#39;B\u0026#39;: 8, \u0026#39;C\u0026#39;: 1, \u0026#39;D\u0026#39;: 2}, \u0026#39;B\u0026#39;: {}, \u0026#39;C\u0026#39;: {\u0026#39;B\u0026#39;: 5, \u0026#39;D\u0026#39;: 2}, \u0026#39;D\u0026#39;: {\u0026#39;E\u0026#39;: 3, \u0026#39;F\u0026#39;: 5}, \u0026#39;E\u0026#39;: {\u0026#39;F\u0026#39;: 1}, \u0026#39;F\u0026#39;: {\u0026#39;A\u0026#39;: 5} } graph2 = { \u0026#39;A\u0026#39;: {\u0026#39;B\u0026#39;: 100, \u0026#39;C\u0026#39;: 2}, \u0026#39;B\u0026#39;: {\u0026#39;C\u0026#39;: 400, \u0026#39;E\u0026#39;: 1}, \u0026#39;C\u0026#39;: {\u0026#39;E\u0026#39;: 4, \u0026#39;D\u0026#39;: 2}, \u0026#39;D\u0026#39;: {\u0026#39;E\u0026#39;: 3}, \u0026#39;E\u0026#39;: {} }   다음 노드를 선택하는 방식을 heapq로 사용하면 알고리즘은 아래와 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import heapq def dijkstra_using_heapq(graph, start): distances = {node: float(\u0026#39;inf\u0026#39;) for node in graph} distances[start] = 0 queue = [] heapq.heappush(queue, (distances[start], start)) while queue: current_distance, current_node = heapq.heappop(queue) if distances[current_node] \u0026lt; current_distance: continue for adj_node, d in graph[current_node].items(): new_distance = current_distance + d if new_distance \u0026lt; distances[adj_node]: distances[adj_node] = new_distance heapq.heappush(queue, (new_distance, adj_node)) return distances   다음 노드를 선택하는 방식을 일반 리스트로 사용하면 아래와 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  def dijkstra_using_adj(graph, start): def get_min_node(current_node, graph, visited): min_node = None min_distance = float(\u0026#39;inf\u0026#39;) for node, distance in graph[current_node].items(): if visited[node] != False: continue if min_distance \u0026gt; distance: min_distance = distance min_node = node if min_node == None: for node, is_visited in visited.items(): if not is_visited: min_node = node return min_node shortest_distances = {node: float(\u0026#39;inf\u0026#39;) for node in graph} shortest_distances[start] = 0 shortest_distances.update(graph[start]) visited = {node: False for node in graph} visited[start] = True current_node = start while False in visited.values(): current_node = get_min_node(current_node, graph, visited) for node, d in graph[current_node].items(): new_distance = shortest_distances[current_node] + d if shortest_distances[node] \u0026gt; new_distance: shortest_distances[node] = new_distance visited[current_node] = True return shortest_distances   6. 전체 통합 소스 및 실행 결과    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  import heapq graph1 = { \u0026#39;A\u0026#39;: {\u0026#39;B\u0026#39;: 8, \u0026#39;C\u0026#39;: 1, \u0026#39;D\u0026#39;: 2}, \u0026#39;B\u0026#39;: {}, \u0026#39;C\u0026#39;: {\u0026#39;B\u0026#39;: 5, \u0026#39;D\u0026#39;: 2}, \u0026#39;D\u0026#39;: {\u0026#39;E\u0026#39;: 3, \u0026#39;F\u0026#39;: 5}, \u0026#39;E\u0026#39;: {\u0026#39;F\u0026#39;: 1}, \u0026#39;F\u0026#39;: {\u0026#39;A\u0026#39;: 5} } graph2 = { \u0026#39;A\u0026#39;: {\u0026#39;B\u0026#39;: 100, \u0026#39;C\u0026#39;: 2}, \u0026#39;B\u0026#39;: {\u0026#39;C\u0026#39;: 400, \u0026#39;E\u0026#39;: 1}, \u0026#39;C\u0026#39;: {\u0026#39;E\u0026#39;: 4, \u0026#39;D\u0026#39;: 2}, \u0026#39;D\u0026#39;: {\u0026#39;E\u0026#39;: 3}, \u0026#39;E\u0026#39;: {} } def dijkstra_using_heapq(graph, start): distances = {node: float(\u0026#39;inf\u0026#39;) for node in graph} distances[start] = 0 queue = [] heapq.heappush(queue, (distances[start], start)) while queue: current_distance, current_node = heapq.heappop(queue) if distances[current_node] \u0026lt; current_distance: continue for adj_node, d in graph[current_node].items(): new_distance = current_distance + d if new_distance \u0026lt; distances[adj_node]: distances[adj_node] = new_distance heapq.heappush(queue, (new_distance, adj_node)) return distances def dijkstra_using_adj(graph, start): def get_min_node(current_node, graph, visited): min_node = None min_distance = float(\u0026#39;inf\u0026#39;) for node, distance in graph[current_node].items(): if visited[node] != False: continue if min_distance \u0026gt; distance: min_distance = distance min_node = node if min_node == None: for node, is_visited in visited.items(): if not is_visited: min_node = node return min_node shortest_distances = {node: float(\u0026#39;inf\u0026#39;) for node in graph} shortest_distances[start] = 0 shortest_distances.update(graph[start]) visited = {node: False for node in graph} visited[start] = True current_node = start while False in visited.values(): current_node = get_min_node(current_node, graph, visited) for node, d in graph[current_node].items(): new_distance = shortest_distances[current_node] + d if shortest_distances[node] \u0026gt; new_distance: shortest_distances[node] = new_distance visited[current_node] = True return shortest_distances print(\u0026#34;--graph1--\u0026#34;) print(graph1) print(\u0026#34;---------------------\u0026#34;) print(dijkstra_using_heapq(graph1, \u0026#34;A\u0026#34;)) print(dijkstra_using_adj(graph1, \u0026#34;A\u0026#34;)) print(\u0026#34;\\n\\n\u0026#34;) print(\u0026#34;--graph2--\u0026#34;) print(graph2) print(\u0026#34;---------------------\u0026#34;) print(dijkstra_using_heapq(graph2, \u0026#34;A\u0026#34;)) print(dijkstra_using_adj(graph2, \u0026#34;A\u0026#34;))   실행 결과\n     "},{"id":9,"href":"/Database/a065dad7-357d-46d5-8752-331522d142d7/","title":"[기초] 1. ACID에 대하여","parent":"Database","content":" 이 블로그는 Notion에서 랜더링 자동화를 통해 제작되었습니다.\nNotion 페이지에 최적화되어있습니다. → [기초] 1. ACID에 대하여\n  ACID    Atomicity Consistency Isolation Durability     더 읽어보기 출처    ACID    ACID란? Atomicity, Consistency, Isolation, Durability를 의미하며 Transaction 이 안전하게 수행기위해 필요한 4가지 성질들을 의미한다.\nTransaction 이란? 데이터베이스 내에서 하나의 기능을 수행하기 위해 행해지는 여러 쿼리의 집합이다.\n     👉DB 스터디를 시작하게 된 이유는 하나의 의문에서 비롯되었다. \u0026quot;은행은 DB 연산을 어떻게 안전하게 하는가?\u0026quot; 즉 안전한 트랜잭션이 어떻게 이루어지는가가 궁금했었다. 동시에 여러 요청을 어떻게 충돌없이 안전하게 처리하는가? 분산 DB라면? 완벽한 동기화가 가능한가? 하드웨어 레벨까지도 안전한 트랜잭션이 수립될 수 있나? 등등의 의문들을 알아가는것이 목표다. \nAtomicity    원자성이라고 한다. 하나의 트랜잭션은 쪼갤 수 없다. 즉 반만 성공하거나 반만 실패할 수 없다. 하나의 쿼리가 실패한다면 그 전까지 실행되던 쿼리들은 모두 롤백해야한다.\n     반만 성공할 수 없다. 트랜잭션 하나에 대한 성공 혹은 실패만 있을 뿐이다.\nConsistency    성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다. 트랜잭션의 수행을 데이터베이스 상태 간의 전이(transition)로 봤을 때, 트랜잭션 수행 전후의 데이터베이스 상태는 각각 일관성이 보장되는 서로 다른 상태가 된다. 트랜잭션 수행이 보존해야 할 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라, 자금 이체 예에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있다.\nConsistency in Data\n데이터 일관성이란 데이터상으로 일관성이 유지되어야 함을 말한다. (정합성)\n     SBS를 구독하는 유저e가 구독자 테이블에 추가되면 채널테이블에도 이 정보가 반영되어야한다.\n유저는 퍼포먼스와 일관성 사이에서 조절가능하다. 예를들어 Youtube 구독자수를 나타낼 때, 1,020,364라는 정확한 수 대신 1000K로 나타내는 것이 그 예다. 어느정도의 근사값만 구해주고 퍼포먼스 상의 이득을 볼 수 있다.\nConsistency in Read\n읽기 일관성이란 데이터를 읽는 트랜잭션의 결과가 일관되어야한다는 것이다.\n즉 읽기 일관성이 없다면 업데이트 트랜잭션이 성공적으로 커밋되었음에도 읽기 트랜잭션이 과거값을 읽어가게된다. 이러한 상황은 DB서버를 확장했을 때 발생한다.\nMaster DB서비의 값은 업데이트되었으나 Slave DB서버에서는 네트워크 지연 등의 이유로 아직 업데이트가 안되었을 때 old value를 읽게 되는 경우가 발생한다.\n     Eventual consistency란 단기적으로는 일관성을 잃더라도 결국에는 일관성을 유지하는 모델을 뜻한다.\n💡후에 다루어질 내용일 것 같다. 데이터베이스 Lock과 관련하여, RDBMS에서는 정해진 레벨링이 되어있기때문에 row, column에 Lock을 건다면, 하위레벨을 자유롭게 저장하는 Nosql에서는? \nIsolation    Isolation이란 하나의 트랜잭션이 다른 트랜잭션과 격리되어 서로의 내용을 참조할 수 없는 성질이다. 즉 Isolation성질이 지켜진다면 트랜잭션 중간에는 다른 트랜잭션의 영향을 받지 않아야한다.\n그러나 Isolation level 에 따라 (동시성에 따른)성능과 Read Phenomena 를 조율할 수 있다. Read phenomena란 데이터베이스 읽기 이상현상정도로 이해하면 된다.\n     Isolation 수준은 위 표에서와 같이 4가지가 있다.\nRead Uncommitted → Read Committed → Repeatable Read → Serializable 순으로 갈수록 Isolation 정도가 강해진다. Isolation 정도가 강해질수록 동시성은 낮아지며 이에 따른 성능저하가 발생한다. 반대로 데이터 정합성은 더 견고해져 Read Phenomena가 줄어들게된다.\n▼ Isolation Level 모아보기 ↕  Read uncommitted    Isolation이 없는 수준이다. Transaction의 중간내용을 다른 Transaction에서 참조할 수 있다.\n👉읽기전용으로만 사용해야 한다.  발생가능한 Read Phenomena : Dirty reads, Lost updates, Non-repetable read, Phantom read  Read committed (Default)    Transaction 내 각각의 쿼리는 다른 Transaction의 Commit완료된 결과만 참조할 수 있다.\n 발생가능한 Read Phenomena : Lost updates, Non-repetable read, Phantom read  Repeatable Read    Transaction 중간중간 Update Undo 상태를 백업해둠으로써 서로 다른 트랜잭션 사이에 업데이트 영향을 받지 않게한다. → 자세히 - REPEATABLE READ\n 발생가능한 Read Phenomena : Phantom read  Serializable    모든 트랜잭션이 직렬화된다. 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 접근 불가능하므로 정합성이 유지된다. 하지만 동시성이 낮아져 성능이 감소한다.\n발생가능한 Read Phenomena : -\n  ▼ Read phenomena 모아보기 ↕  Dirty reads    커밋되지 않은 트랜잭션의 데이터를 다른 트랜잭션이 읽을 수 있다.\n     Lost updates \u0026amp; Non-repeatable read    값을 업데이트하는 트랜잭션이 다른 트랜잭션의 업데이트 작업에 의해 적용되지 않는다(Lost Update).\n이 영향으로 하나의 트랜잭션에서 같은 쿼리를 두번이상 수행할때, 똑같은 쿼리임에도 다른 결과가 나오는 현상(Non-repeatable read)\n     Phantom reads    하나의 트랜잭션에서 일정 범위의 레코드를 두번 이상 읽을 때, 똑같은 쿼리임에도 없던 레코드가 두번째 쿼리에서 나타나는 현상\n       Durability    성공한 트랜잭션은 영구적으로 결과에 반영되어야하는 성질이다. 비활성 스토리지에 커밋 로그를 저장함으로서 구현할 수 있다.\n예를 들어서 항공예약시스템에서 예약이 성공적으로 완료되었다면 시스템이 크래쉬가 나더라도 예약은 유지되야한다.\n👉분산트랜잭션에서는 묶여있는 모든 서버가 커밋이 완료되기 전에 조율해야한다. 통상적으로 이는 two-phase commit protocol 에 의해서 행해진다. \n 더 읽어보기     DBMS는 어떻게 트랜잭션을 관리할까? - Naver D2  출처     Introduction to Database Engineering  "},{"id":10,"href":"/","title":"@hwangseonbi","parent":"","content":"\nHi, I\u0026rsquo;m Taehoon.  About Me I live in Korea 🇰🇷 and work as an Backend Developer 👨‍💻. I\u0026rsquo;m fond of sports 🔥 and especially like playing futsal ⚽. You can also find me in  Github,  Notion.  Here`](google.com) are some projects I have made. -- "},{"id":11,"href":"/categories/","title":"Categories","parent":"@hwangseonbi","content":""},{"id":12,"href":"/tags/","title":"Tags","parent":"@hwangseonbi","content":""}]